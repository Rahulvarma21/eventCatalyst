"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var _require = require('lodash'),
  assign = _require.assign,
  identity = _require.identity,
  negate = _require.negate;
var _require2 = require('path'),
  dirname = _require2.dirname,
  relative = _require2.relative,
  resolve = _require2.resolve;
var _require3 = require('fs'),
  readFileSync = _require3.readFileSync;
var globToRegex = require('glob-to-regexp');
var postcss = require('postcss');
var Values = require('postcss-modules-values');
var LocalByDefault = require('postcss-modules-local-by-default');
var ExtractImports = require('postcss-modules-extract-imports');
var Scope = require('postcss-modules-scope');
var ResolveImports = require('@dr.pogodin/postcss-modules-resolve-imports');
var debugFetch = require('debug')('css-modules:fetch');
var debugSetup = require('debug')('css-modules:setup');
var getGenerateScopedName = require('./getGenerateScopedName');
var validate = require('./validate');
var attachHook = require('./attachHook');
var _require4 = require('./transformTokens'),
  transformTokens = _require4.transformTokens;

/**
 * @param  {*} option
 * @return {array}
 */
function toArray(option) {
  return Array.isArray(option) ? option : [option];
}

/**
 * @param  {function|regex|string} ignore glob, regex or function
 * @return {function}
 */
function buildExceptionChecker(ignore) {
  if (ignore instanceof RegExp) return function (filepath) {
    return ignore.test(filepath);
  };
  if (typeof ignore === 'string') return function (filepath) {
    return globToRegex(ignore).test(filepath);
  };
  return ignore || negate(identity);
}
module.exports = function setupHook(options) {
  var camelCase = options.camelCase,
    devMode = options.devMode,
    _options$extensions = options.extensions,
    extensions = _options$extensions === void 0 ? '.css' : _options$extensions,
    ignore = options.ignore,
    _options$preprocessCs = options.preprocessCss,
    preprocessCss = _options$preprocessCs === void 0 ? identity : _options$preprocessCs,
    processCss = options.processCss,
    processorOpts = options.processorOpts,
    _options$append = options.append,
    append = _options$append === void 0 ? [] : _options$append,
    _options$prepend = options.prepend,
    prepend = _options$prepend === void 0 ? [] : _options$prepend,
    createImportedName = options.createImportedName,
    _options$hashPrefix = options.hashPrefix,
    hashPrefix = _options$hashPrefix === void 0 ? '' : _options$hashPrefix,
    mode = options.mode,
    resolveOpts = options.resolve,
    use = options.use,
    _options$rootDir = options.rootDir,
    context = _options$rootDir === void 0 ? process.cwd() : _options$rootDir;
  debugSetup(options);
  validate(options);

  /* An attempt to fix
   * https://github.com/css-modules/css-modules-require-hook/issues/115
   */
  var processCssQueue = [];
  var processCssPlugin = processCss && function () {
    return {
      postcssPlugin: 'process-css-plugin',
      Once: function Once(root) {
        var tree = root.clone();
        tree.walkRules(function (rule) {
          if (rule.selector && rule.selector.match(/^:(export|import)/)) {
            rule.remove();
          }
        });
        processCssQueue.push({
          css: tree.toString(),
          file: tree.source.input.file
        });
      }
    };
  };
  if (processCssPlugin) processCssPlugin.postcss = true;
  var exts = toArray(extensions);
  var tokensByFile = {};

  // debug option is preferred NODE_ENV === 'development'
  var debugMode = typeof devMode !== 'undefined' ? devMode : process.env.NODE_ENV === 'development';
  var generateScopedName = options.generateScopedName;
  if (typeof generateScopedName !== 'function') {
    generateScopedName = generateScopedName ? getGenerateScopedName(context, generateScopedName, hashPrefix) : function (local, filename) {
      return Scope.generateScopedName(local, relative(context, filename));
    };
  }
  var plugins = use;
  if (!plugins) {
    var _plugins;
    plugins = [].concat(_toConsumableArray(prepend), [Values, LocalByDefault({
      mode: mode
    }), ExtractImports({
      createImportedName: createImportedName
    }), Scope({
      generateScopedName: generateScopedName
    })]);
    if (processCssPlugin) plugins.push(processCssPlugin);
    (_plugins = plugins).push.apply(_plugins, [new ResolveImports({
      resolve: _objectSpread({
        extensions: exts
      }, resolveOpts)
    })].concat(_toConsumableArray(append)));
  }

  // https://github.com/postcss/postcss#options
  var runner = postcss(plugins);

  /**
   * @todo   think about replacing sequential fetch function calls with requires calls
   * @param  {string} _to
   * @param  {string} from
   * @return {object}
   */
  function fetch(_to, from) {
    // getting absolute path to the processing file
    var filename = /[^\\/?%*:|"<>.]/i.test(_to[0]) ? require.resolve(_to) : resolve(dirname(from), _to);

    // checking cache
    var tokens = tokensByFile[filename];
    if (tokens) {
      debugFetch("".concat(filename, " \u2192 cache"));
      debugFetch(tokens);
      return tokens;
    }
    var source = preprocessCss(readFileSync(filename, 'utf8'), filename);
    // https://github.com/postcss/postcss/blob/master/docs/api.md#processorprocesscss-opts
    var lazyResult = runner.process(source, assign({}, processorOpts, {
      from: filename
    }));

    // https://github.com/postcss/postcss/blob/master/docs/api.md#lazywarnings
    lazyResult.warnings().forEach(function (message) {
      return console.warn(message.text);
    });
    tokens = lazyResult.root.exports || {};
    if (!debugMode) {
      // updating cache
      tokensByFile[filename] = tokens;
    } else {
      // clearing cache in development mode
      delete require.cache[filename];
    }
    if (processCss) {
      processCssQueue.reverse();
      processCssQueue.forEach(function (_ref) {
        var css = _ref.css,
          file = _ref.file;
        return processCss(css, file);
      });
    }
    debugFetch("".concat(filename, " \u2192 fs"));
    debugFetch(tokens);
    return tokens;
  }
  var isException = buildExceptionChecker(ignore);
  var hook = function hook(filename) {
    var tokens = fetch(filename, filename);
    return camelCase ? transformTokens(tokens, camelCase) : tokens;
  };

  // @todo add possibility to specify particular config for each extension
  exts.forEach(function (extension) {
    return attachHook(hook, extension, isException);
  });
};